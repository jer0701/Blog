<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[浅谈富文本编辑]]></title>
      <url>http://yuanjer.com/2017/03/24/ContentEditable/</url>
      <content type="html"><![CDATA[<p>最近做的一个demo用到了富文本编辑，</p>
<p>然后我使用React框架来重写这个demo，需要处理富文本编辑功能，就有了此文章</p>
<a id="more"></a>
<h3 id="说在前面的话"><a href="#说在前面的话" class="headerlink" title="说在前面的话"></a>说在前面的话</h3><p>富文本编辑，又称为WYSIWYG（What You See Is What You Get，所见即所得），</p>
<p>该技术的本质，就是在页面中嵌入一个包含空HTML页面的iframe。</p>
<p>JavaScript实现富文本有两种方式，一种是使用<code>iframe</code>元素，另一种是使用<code>contenteditable</code>属性，本文讲的是后一种方法。</p>
<p><br></p>
<h3 id="使用contenteditable属性"><a href="#使用contenteditable属性" class="headerlink" title="使用contenteditable属性"></a>使用contenteditable属性</h3><p>可以把<code>contenteditable</code>属性应用给页面的任何元素，然后用户立即就可以编辑该元素。这种方法很受欢迎，因为它不需要iframe、空白页和JavaScript，只要为元素设置<code>contenteditable</code>属性即可，如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"editable"</span> <span class="attr">contenteditable</span>==<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>contenteditable</code>属性有三个可能的值：“true”表示打开、“false”表示关闭、“inherit”表示可以从父元素那里继承。</p>
<p><br></p>
<h3 id="React中使用"><a href="#React中使用" class="headerlink" title="React中使用"></a>React中使用</h3><p>我在重写demo的时候是将可编辑的div做成react控件，以此达到目的。</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ContentEditable = React.createClass(&#123;</div><div class="line">            <span class="attr">shouldComponentUpdate</span>: <span class="function"><span class="keyword">function</span>(<span class="params">nextProps</span>)</span>&#123;</div><div class="line">                <span class="keyword">return</span> nextProps.html !== ReactDOM.findDOMNode(<span class="keyword">this</span>).innerHTML;</div><div class="line">            &#125;,</div><div class="line"></div><div class="line">            <span class="attr">editChange</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                <span class="keyword">var</span> html = ReactDOM.findDOMNode(<span class="keyword">this</span>).innerHTML;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.props.onChange &amp;&amp; html !== <span class="keyword">this</span>.lastHtml) &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">this</span>.props.onChange(&#123;</div><div class="line">                        <span class="attr">target</span>: &#123;</div><div class="line">                            <span class="attr">value</span>: html</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">this</span>.lastHtml = html;</div><div class="line">            &#125;,</div><div class="line"></div><div class="line">            <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"t_contant"</span></span></span></div><div class="line">                    <span class="attr">onInput</span>=<span class="string">&#123;this.editChange&#125;</span></div><div class="line">                    <span class="attr">onBlur</span>=<span class="string">&#123;this.editChange&#125;</span></div><div class="line">                    <span class="attr">contentEditable</span>=<span class="string">"true"</span></div><div class="line">                    <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;__html:</span> 		<span class="attr">this.props.html</span>&#125;&#125;&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>由于<code>div</code>标签没有onChange事件，所以需要用onInput和onBlur来代替。</p>
<p>dangerouslySetInnerHTML是React特有的属性，用于提供插入纯 HTML 字符串的功能。</p>
<p>好的，基于以上控件，可编辑的div可用于React中。</p>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> contenteditable </tag>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[React之扫盲]]></title>
      <url>http://yuanjer.com/2017/03/23/React3/</url>
      <content type="html"><![CDATA[<p>学习React有一段时间了，React有一些细节还是要注意的。</p>
<p>本文便于扫盲~</p>
<a id="more"></a>
<p>不多说废话，直接点出：</p>
<ol>
<li><p>React的核心是组件，那么第一个细节点是，组件类名<strong>第一个字母</strong>一定要<strong>大写</strong>，之前有过一篇文章提到过阮一峰老师的关于react入门教程，里面也提醒了这点，不过阮老师写的是：组件类的第一个字母必须大写，否则会报错。这里补充一下，不一定会报错，现代浏览器有很强的兼容性，这种可能不会报错，但是效果一定是显示不出来的。</p>
<p>​</p>
</li>
<li><p>在render的时候，行内样式不再是一个字符串，它是一个{}对象，值需要用{}括起来。</p>
<p>​</p>
</li>
<li><p>React在访问像素为单位的属性的时候，它会自动补全px，所以我们在添加的时候，可以省略单位px，这也方便了我们在组件类内部对这些属性的计算等。</p>
<p>​</p>
</li>
<li><p>在组件中，所有的标签必须要有结束标签，例如img标签，一定要这样<code>&lt;img /&gt;</code>,不然就会报错，切记！</p>
<p>​</p>
</li>
<li><p>render的时候只能有<strong>一个</strong>根节点，Only one!</p>
<p>​</p>
</li>
<li><p>只有state改变了的时候，组件才会重新渲染，这个一般问题不大，这是React的核心算法。</p>
<p>​</p>
</li>
<li><p>ref属性一般通过ReactDOM.findDOMNode方法来使用，查找真实的DOM节点。所有一般也在componentDidMount函数中使用ReactDOM.findDOMNode方法，因为这个时候DOM节点已经存在了。</p>
</li>
</ol>
<p>个人能力暂时有限，目前只有这些。</p>
<p>๑乛◡乛๑</p>
]]></content>
      
        
        <tags>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[React之通信]]></title>
      <url>http://yuanjer.com/2017/03/21/React2/</url>
      <content type="html"><![CDATA[<p>今天这篇文章的目的是总结我今天做项目碰到的问题</p>
<p>方便以后查阅</p>
<a id="more"></a>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>先描述一下需求，我想在父组件（Heart）中添加子组件（Shadow），且子组件有很多个。子组件（Shadow）其他内容都相同，就是Color不同，所以只要在Shadow render的时候添加不同的颜色样式就可以了。</p>
<p><br><br></p>
<h4 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h4><p>在父组件中有个button，每点击一次产生一个阴影即添加一个子组件。</p>
<p>怎么控制呢？</p>
<p>在父组件中添加一个state：shadows[]数组, 数组保存的是每一个子组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="keyword">return</span> &#123; <span class="attr">shadows</span>: [] &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当执行点击函数时，我们就push一个子组件进去，这样就可以点击一次添加一个子组件了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">handleClick: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">     <span class="keyword">var</span> temp = <span class="keyword">this</span>.state.shadows;</div><div class="line">     temp.push(<span class="xml"><span class="tag">&lt;<span class="name">Shadow</span> /&gt;</span>);</span></div><div class="line">     this.setState(&#123;shadows: temp&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br><br></p>
<p><br><br></p>
<h4 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h4><p>解决问题一之后就会出现第二个问题，就是每添加一个子组件，都会产生一个DOM节点，不断的点击，就会保存很多个相同的DOM节点，因为每个子组件出现的效果只会显示很短的时间，效果没了之后，这些节点没有存在的必要了，所以有必要在效果结束之后删除这些节点。</p>
<p>问题来了，那么怎么删除呢？</p>
<p>在这一步我卡了较久的时间，最开始想通过子组件自己删除自己，没有实现。。。</p>
<p>最后发现，可以根据问题一的解决来实现，通过父组件来删除子组件！</p>
<p>在问题一种，我们添加了一个state：shadows[]数组，那么我每次从数组中pop出或者shift出一个元素，那不就可以了么。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">clearShadow: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">           <span class="keyword">var</span> temp = <span class="keyword">this</span>.state.shadows;</div><div class="line">           temp.shift();</div><div class="line">           <span class="keyword">this</span>.setState(&#123;<span class="attr">shadows</span>: temp&#125;);</div><div class="line">     &#125;.bind(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br><br></p>
<p>接下来是什么时候删除呢，当然是效果完成之后，也就是子组件render之后。</p>
<p>所以我在子组件的componentDidMount函数中调用父组件的清除函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">         <span class="keyword">this</span>.props.clearShadow();</div><div class="line">     &#125;.bind(<span class="keyword">this</span>), <span class="number">10000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为什么在componentDidMount函数中调用呢，这就要谈及到组件的生命周期了。</p>
<p>这个可以查看<a href="https://facebook.github.io/react/docs/react-component.html" target="_blank" rel="external">官方文档</a></p>
<p>我在这里提一下生命周期提供的API:</p>
<ol>
<li><p>getDefaultProps</p>
<p>作用于组件类，只调用一次，返回对象用于设置默认的<code>props</code>，对于引用值，会在实例中共享</p>
</li>
<li><p>getInitialState</p>
<p>作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的<code>state</code>，此时可以访问<code>this.props</code></p>
</li>
<li><p>componentWillMount</p>
<p>在完成首次渲染之前调用，此时仍可以修改组件的state</p>
</li>
<li><p>render</p>
<p>必选的方法，创建虚拟DOM</p>
</li>
<li><p>componentDidMount</p>
<p>真实的DOM被渲染出来后调用，在该方法中可访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM</p>
</li>
<li><p>componentWillReceiveProps</p>
<p>组件接收到新的<code>props</code>时调用，并将其作为参数<code>nextProps</code>使用，此时可以更改组件<code>props</code>及<code>state</code></p>
</li>
<li><p>shouldComponentUpdate</p>
<p>组件是否应当渲染新的<code>props</code>或<code>state</code>，返回<code>false</code>表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化</p>
</li>
<li><p>componentWillUpdate</p>
<p>接收到新的<code>props</code>或者<code>state</code>后，进行渲染之前调用，此时不允许更新<code>props</code>或<code>state</code></p>
</li>
<li><p>componentDidUpdate</p>
<p>完成渲染新的<code>props</code>或者<code>state</code>后调用，此时可以访问到新的DOM元素</p>
</li>
<li><p>componentWillUnmount</p>
<p>组件被移除之前被调用，可以用于做一些清理工作，在<code>componentDidMount</code>方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器</p>
</li>
</ol>
<p><br><br></p>
<p><br><br></p>
<p>博客标题是React之通信，今天说的就是父组件和子组件之间通信，有如下两个方法：</p>
<p>父组件调用子组件的方法：使用ref属性，子组件是一个DOM节点，可以通过<code>this.refs.[refName]</code> 就会返回这个真实的 DOM 节点。</p>
<p>子组件调用父组件方法：使用props属性，就是我今天使用的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">temp.push(<span class="xml"><span class="tag">&lt;<span class="name">Shadow</span> <span class="attr">clearShadow</span>=<span class="string">&#123;this.clearShadow()&#125;/</span>&gt;</span>);</span></div></pre></td></tr></table></figure>
<p>然后就可以通过<code>this.props.clearShadow()</code>来调用了。</p>
<p>完美~</p>
]]></content>
      
        
        <tags>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Canvas]]></title>
      <url>http://yuanjer.com/2017/03/20/Canvas/</url>
      <content type="html"><![CDATA[<p>HTML5添加的最受欢迎的功能就是canvas元素</p>
<p>今天我就来学习学习它。</p>
<a id="more"></a>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>与浏览器环境中的其他组件类似，canvas由几组API构成，但非所有的浏览器都支持这些API。除了具备基本绘制能力的2D上下文，还有个WebGL的3D上下文。</p>
<p>要使用canvas元素，必须先设置其width和height属性，指定绘图的区域大小。出现在开始和结束标签中的内容是后备信息，如果浏览器不支持canvas元素，就会显示这些信息。如下</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"drawing"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"200"</span>&gt;</span>Info<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></div></pre></td></tr></table></figure>
<p>要在这块画布（canvas）上绘图，需要获得绘图上下文。通过getContext()方法调用,</p>
<p>传入“2d”，就可以获得2D上下文对象,如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> draw = <span class="built_in">document</span>.getElementById(<span class="string">"drawing"</span>);</div><div class="line"><span class="keyword">if</span> (draw.getContext) &#123; <span class="comment">//判断浏览器是否支持canvas元素</span></div><div class="line">	<span class="keyword">var</span> context = draw.getContext(<span class="string">"2d"</span>);</div><div class="line">  	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br><br></p>
<p><br><br></p>
<h3 id="2D上下文"><a href="#2D上下文" class="headerlink" title="2D上下文"></a>2D上下文</h3><p>使用2D绘图上下文提供的方法，可以绘制简单的2D图形，如矩形。2D上下文的坐标开始与canvas元素的左上角，坐标是(0,0)。所有坐标值基于这个点计算。</p>
<h4 id="填充和描边"><a href="#填充和描边" class="headerlink" title="填充和描边"></a>填充和描边</h4><p>2D上下文两种基本的操作就是填充和描边。操作的属性是：fillStyle和strokeStyle。</p>
<p>这两个属性的值默认都是“#000000”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> context = draw.getContext(<span class="string">"2d"</span>);</div><div class="line">context.strokeStyle = <span class="string">"red"</span>;</div><div class="line">context.fillStyle = <span class="string">"#0000ff"</span>; <span class="comment">//蓝色</span></div></pre></td></tr></table></figure>
<p><br><br></p>
<h4 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//红色填充矩形</span></div><div class="line">context.fillStyle = <span class="string">"red"</span>;</div><div class="line">context.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//红色描边矩形</span></div><div class="line">context.strokeStyle = <span class="string">"red"</span>;</div><div class="line">context.strokeRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在两个矩形重叠的地方清除一个小矩形</span></div><div class="line">context.fillStyle = <span class="string">"red"</span>;</div><div class="line">context.fillRect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">50</span>,<span class="number">50</span>);</div><div class="line">context.fillStyle = <span class="string">"rgba(0, 0, 255, 0.5)"</span>;</div><div class="line">context.fillRect(<span class="number">30</span>,<span class="number">30</span>,<span class="number">50</span>,<span class="number">50</span>);</div><div class="line">context.clearRect(<span class="number">40</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">10</span>);</div></pre></td></tr></table></figure>
<p><br><br></p>
<h4 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h4><p>要绘制路径，首先必须调用beginPath()方法，表示要开始绘制新路径了。</p>
<p>绘制路有很多方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">arc(x, y, radius, startAngle, endAngle, counterclockwise)</div><div class="line">arcTo(x1, y1, x2, y2, radius)</div><div class="line">bezierCurveTo(c1x, c1y, c2x, c2y, x, y)<span class="comment">//绘制曲线，到x,y为止,途经c1,c2</span></div><div class="line">lineTo(x, y)</div><div class="line">moveTo(x, y)<span class="comment">//移动光标，不画线</span></div><div class="line">rect(x, y, width, height)</div></pre></td></tr></table></figure>
<p>看如下例子，绘制不带数字的时钟</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开始路径</span></div><div class="line">context.beginPath();</div><div class="line"><span class="comment">//绘制外圆</span></div><div class="line">context.arc(<span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">0</span>, <span class="number">2</span>*<span class="built_in">Math</span>.PI, <span class="literal">false</span>);</div><div class="line"><span class="comment">//绘制内圆</span></div><div class="line">context.moveTo(<span class="number">194</span>, <span class="number">100</span>);</div><div class="line">context.arc(<span class="number">100</span>, <span class="number">100</span>, <span class="number">94</span>, <span class="number">0</span>, <span class="number">2</span>*<span class="built_in">Math</span>.PI, <span class="literal">false</span>);</div><div class="line"><span class="comment">//绘制分针</span></div><div class="line">context.moveTo(<span class="number">100</span>, <span class="number">100</span>);</div><div class="line">context.lineTo(<span class="number">100</span>, <span class="number">15</span>);</div><div class="line"><span class="comment">//绘制时针</span></div><div class="line">context.moveTo(<span class="number">100</span>, <span class="number">100</span>);</div><div class="line">context.lineTo(<span class="number">35</span>, <span class="number">100</span>);</div><div class="line"><span class="comment">//描边刚刚画的路径</span></div><div class="line">context.stroke();</div></pre></td></tr></table></figure>
<p><br><br></p>
<h4 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h4><p>绘制文本有两个方法：fillText() 和strokeText()。这两个方法都可以接收四个参数：要绘制的字符串、x坐标、y坐标和可选的最大像素宽度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">context.font = <span class="string">"blod 14px Microsoft"</span>;</div><div class="line">context.textAlign = <span class="string">"center"</span>;</div><div class="line">context.textBaseLine = <span class="string">"middle"</span>;</div><div class="line">context.fillText(<span class="string">"12"</span>, <span class="number">100</span>, <span class="number">20</span>);</div></pre></td></tr></table></figure>
<p><br><br></p>
<h4 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h4><p>变换就是使用不同的变换矩阵处理图像，有如下变换矩阵：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">rotate(angle) <span class="comment">//围绕原点旋转</span></div><div class="line">scale(scaleX, scaleY) <span class="comment">//x,轴缩放</span></div><div class="line">translate(x, y) <span class="comment">//将原点坐标移到x,y，即(x,y)代表原点</span></div><div class="line">transform(m1_1, m1_2, m2_1, m2_2, dx, dy) <span class="comment">//自定义修改矩阵</span></div><div class="line">setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy) <span class="comment">//先把矩阵恢复默认再进行transform</span></div></pre></td></tr></table></figure>
<p><br><br></p>
<h4 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h4><p>使用drawImage()方法就可以把图像绘制到画布上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">drawImage(image, x, y) <span class="comment">//参数不固定，可以更多</span></div></pre></td></tr></table></figure>
<p><br><br></p>
<h4 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h4><p>2D上下文会根据以下几个属性的值，自动为形状或路径绘制出阴影</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">shadowColor: 用CSS颜色格式表示阴影颜色，默认黑色</div><div class="line">shadowOffsetX: x轴方向阴影偏移量，默认为<span class="number">0</span></div><div class="line">shadowOffsetY: Y轴方向阴影偏移量，默认为<span class="number">0</span></div><div class="line">shadowBlur: 模糊的像素数，默认为<span class="number">0</span>，即不模糊</div></pre></td></tr></table></figure>
<p>这些属性可以通过context对象来修改，只要在绘制之前设置合适的值，就能自动产生阴影。例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">context.shadowOffsetX = <span class="number">5</span>;</div><div class="line">context.shadowOffsetY = <span class="number">5</span>;</div><div class="line">context.Blur = <span class="number">4</span>;</div><div class="line">context.shadowColor = <span class="string">"rgba(0, 0, 0, 0.5)"</span>;</div><div class="line"></div><div class="line">context.fillStyle = <span class="string">"red"</span>;</div><div class="line">context.fillRect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">50</span>,<span class="number">50</span>);</div></pre></td></tr></table></figure>
<p><br><br></p>
<h4 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h4><p>渐变有CanvasGradient实例表示。</p>
<p>Context对象可以通过createLinearGradient()和createRadialGradient()两个方法创建渐变对象，这两个方法的参数如下：</p>
<p><strong>createLinearGradient(x1, y1, x2, y2);</strong></p>
<p>创建一个从(x1, y1)点到(x2, y2)点的<strong>线性</strong>渐变对象。</p>
<p><strong>createRadialGradient(x1, y1, r1, x2, y2, r2);</strong></p>
<p>创建一个从以(x1, y1)点为圆心、r1为半径的圆到以(x2, y2)点为圆心、r2为半径的圆的<strong>径向</strong>渐变对象。</p>
<p>渐变对象创建完成之后必须使用它的addColorStop()方法来添加颜色，该方法的使用如下：</p>
<p><strong>addColorStop(position, color);</strong></p>
<p>其中position表示添加颜色的位置，取值范围为[0, 1]，0表示起点，1表示终点；color表示添加的颜色，取值可以是任何CSS颜色值。</p>
<p>渐变对象创建并配置完成之后就可以将其赋予Context对象的strokeStyle属性或者fillStyle属性，然后绘制的图形就具有了所需的渐变效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gradient = context.createLinearGradient(<span class="number">30</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">70</span>);</div><div class="line">gradient.addColorStop(<span class="number">0</span>, <span class="string">"white"</span>);</div><div class="line">gradient.addColorStop(<span class="number">1</span>, <span class="string">"black"</span>);</div><div class="line"></div><div class="line">context.fillStyle = gradient; <span class="comment">//赋值给fillStyle属性</span></div><div class="line">context.fillRect(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</div></pre></td></tr></table></figure>
<p><br><br></p>
<h4 id="图像数据"><a href="#图像数据" class="headerlink" title="图像数据"></a>图像数据</h4><p>2D上下文的一个明显长处就是，可以通过getImageData()获取原始图像数据。这个方法接收四个参数：要获取器数据的画面区域的x、y坐标已经该区域的像素宽度和高度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//取得左上角坐标为(10,5)，大小为50 x 50像素的区域的图像数据</span></div><div class="line"><span class="keyword">var</span> imageData = context.getImageData(<span class="number">10</span>, <span class="number">5</span>, <span class="number">50</span>, <span class="number">50</span>);</div></pre></td></tr></table></figure>
<p>上述代码返回的对象是ImageData的实例。每个ImageData对象有三个属性：width、height和data。其中data是一个数组，保存着图像每个像素的数据，分别是四个元素：红、绿、蓝和透明度值。例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = imageData.data,</div><div class="line">    red = data[<span class="number">0</span>],</div><div class="line">    green = data[<span class="number">1</span>],</div><div class="line">    blue = data[<span class="number">2</span>],</div><div class="line">    alpha = data[<span class="number">3</span>];</div></pre></td></tr></table></figure>
<p><br><br></p>
<p><br><br></p>
<p>好了，到这里对canvas 2D上下文的基本用法就有了一定的了解，另外还有两个有意思的属性：globalAlpha和globalCompositionOperation，可去测试一下。</p>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> canvas </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[React]]></title>
      <url>http://yuanjer.com/2017/03/20/React/</url>
      <content type="html"><![CDATA[<p>最近在学习React框架，这是前端最热门框架之一了。</p>
<p>碰到过一些坑，在这里记录下来。</p>
<a id="more"></a>
<h3 id="React入门"><a href="#React入门" class="headerlink" title="React入门"></a>React入门</h3><p>React是Facebook开源的项目，是一套性能比较好的框架。为什么呢，因为采取虚拟DOM技术，通过对DOM的模拟，最大限度地减少与DOM的交互。</p>
<p>React代码逻辑比较简单，如果不会的推荐可以看一看阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank" rel="external">入门教程</a></p>
<h3 id="React-Router"><a href="#React-Router" class="headerlink" title="React Router"></a>React Router</h3><p>接下来我讲讲碰到的坑了，没错，就是react路由的坑</p>
<p>react router上手也容易，大家可以去看阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu" target="_blank" rel="external">教程</a></p>
<p>我在代码中是这样使用的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;Router, Route, IndexRoute, hashHistory&#125; <span class="keyword">from</span> <span class="string">'react-router'</span></div><div class="line">...</div><div class="line">ReactDOM.render(</div><div class="line">     (&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class="line">        &lt;Route path='/' component=&#123;App&#125; &gt;</div><div class="line">            &lt;IndexRoute component=&#123;Gallery&#125;/&gt;</div><div class="line">            &lt;Route path='/calculator' component=&#123;Calculator&#125; /&gt;</div><div class="line">        &lt;/Route&gt;</div><div class="line">    &lt;/Router&gt;),</div><div class="line">    document.getElementById('app')</div><div class="line">);</div></pre></td></tr></table></figure>
<p>因为是本地静态页面，所以使用hashHistory。</p>
<p>项目采用yoman脚手架搭建，react router安装是使用如下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -S react-router</div></pre></td></tr></table></figure>
<p>然后npm start运行项目，发现报错了，如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Uncaught TypeError: Cannot <span class="built_in">read</span> property <span class="string">'location'</span> of undefined</div></pre></td></tr></table></figure>
<p>location未定义</p>
<p>可是location是history的呀如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">match:r.computeMatch(r.props.history.location.pathname)</div></pre></td></tr></table></figure>
<p>history等于hashHistory，react-router定义的，怎么会报错呢，郁闷呀。</p>
<p>开始以为是我的代码写错了，然后就去写了个demo，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;../build/react-router.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;</div><div class="line">    &lt;script type=&quot;text/babel&quot;&gt;</div><div class="line">		var Link = ReactRouter.Link;</div><div class="line"> 	var IndexLink = ReactRouter.IndexLink;</div><div class="line"> 	var Router = ReactRouter.Router;</div><div class="line"> 	var Route = ReactRouter.Route;</div><div class="line"> 	var IndexRoute = ReactRouter.IndexRoute;</div><div class="line"> 	var hashHistory = ReactRouter.hashHistory;</div><div class="line">	</div><div class="line">	var App = React.createClass(&#123;</div><div class="line"> 			render : function()&#123;</div><div class="line"> 				return (</div><div class="line"> 					&lt;div className=&quot;container&quot;&gt;</div><div class="line">					Hello world!</div><div class="line"> 					&lt;/div&gt;</div><div class="line"> 				)</div><div class="line"> 			&#125;</div><div class="line"> 		&#125;)</div><div class="line"></div><div class="line">      ReactDOM.render(</div><div class="line">        &lt;Router history=&#123;hashHistory&#125;&gt;</div><div class="line"> 			    &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</div><div class="line"> 			     </div><div class="line"> 			    &lt;/Route&gt;</div><div class="line"> 		    &lt;/Router&gt;,</div><div class="line">        document.getElementById(&apos;example&apos;)</div><div class="line">      );</div><div class="line">    &lt;/script&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>测试发现是OK的，页面显示正常。</p>
<p>但是修改一下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../build/react-router.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  修改成</div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://cdn.bootcss.com/react-router/4.0.0/react-router.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后在测试，发现报一样的错了。</p>
<p>原来我项目中安装react-router是安装最新的4.0的版本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="string">"dependencies"</span>: &#123;</div><div class="line">    <span class="string">"core-js"</span>: <span class="string">"^2.0.0"</span>,</div><div class="line">    <span class="string">"normalize.css"</span>: <span class="string">"^4.0.0"</span>,</div><div class="line">    <span class="string">"react"</span>: <span class="string">"^15.0.0"</span>,</div><div class="line">    <span class="string">"react-addons-css-transition-group"</span>: <span class="string">"^15.4.2"</span>,</div><div class="line">    <span class="string">"react-dom"</span>: <span class="string">"^15.0.0"</span>,</div><div class="line">    <span class="string">"react-router"</span>: <span class="string">"^4.0.0"</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>手动改为”^3.0.0”再npm install生成就OK了。</p>
<p>4.0版本改动比较大，大家可以看下<a href="https://zhuanlan.zhihu.com/p/22490775" target="_blank" rel="external">这篇文章</a></p>
<p>好了，今天就记录到这吧.</p>
]]></content>
      
        
        <tags>
            
            <tag> React </tag>
            
            <tag> React-Router </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[My first blog]]></title>
      <url>http://yuanjer.com/2017/03/19/My-first-blog/</url>
      <content type="html"><![CDATA[<p>这是我的第一篇博客，也代表着我走向<strong>前端</strong>的起点</p>
<p>本文记录了搭建此博客的过程（windows）</p>
<a id="more"></a>
<h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>首先git bash、node.js、github该安装的安装，该申请账号的申请账号，没得问题。</p>
<h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p>先创建一个github仓库，名字随意，如Blog</p>
<p>然后git clone到本地</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator\Desktop\MyProject&gt;git clone git@github.com:jer0701/Blog.git</div></pre></td></tr></table></figure>
<h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><p>npm安装 hexo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator\Desktop\MyProject\Blog&gt;npm install -g hexo</div></pre></td></tr></table></figure>
<p>执行初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator\Desktop\MyProject\Blog&gt;hexo init</div></pre></td></tr></table></figure>
<p>好啦，到这里所有的安装工作都完成啦！</p>
<h3 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator\Desktop\MyProject\Blog&gt;hexo generate</div></pre></td></tr></table></figure>
<h3 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator\Desktop\MyProject\Blog&gt;hexo server</div></pre></td></tr></table></figure>
<p>然后在浏览器输入<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>，可以预览</p>
<p>我当时怎么也查看不了，最后发现把VPN代理关闭就可以看了</p>
<h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><p>需要配置 _config.yml文件</p>
<p>​    deploy:<br>          type: git<br>         repository: git@github.com:jer0701/Blog.git<br>          branch: gh-pages</p>
<p>然后部署</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator\Desktop\MyProject\Blog&gt;npm install hexo-deployer-git --save</div><div class="line">C:\Users\Administrator\Desktop\MyProject\Blog&gt;hexo deployranjo</div></pre></td></tr></table></figure>
<p>然后通过访问<a href="http://jer0701.github.io/Blog/" target="_blank" rel="external">http://jer0701.github.io/Blog/</a>就可以了,至此，一个完整的博客搭建好了，你可以自己配置主题和域名๑乛◡乛๑</p>
<h5 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h5><ul>
<li>hexo deploy 显示Permission denied (publickey).</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">debug1: Authentications that can continue: publickey</div><div class="line">debug1: Next authentication method: publickey</div><div class="line">debug1: Trying private key: /c/Users/Administrator/.ssh/id_rsa</div><div class="line">debug1: Trying private key: /c/Users/Administrator/.ssh/id_dsa</div><div class="line">debug1: Trying private key: /c/Users/Administrator/.ssh/id_ecdsa</div><div class="line">debug1: Trying private key: /c/Users/Administrator/.ssh/id_ed25519</div><div class="line">debug1: No more authentication methods to try.</div><div class="line">Permission denied (publickey).</div><div class="line"></div><div class="line">Administrator@EJ24HRCEX0UU263 MINGW64 ~</div><div class="line">$ ls ~/.ssh</div><div class="line">github_rsa  github_rsa.pub  known_hosts</div><div class="line"></div><div class="line">###将github换成id开头</div><div class="line"></div><div class="line">Administrator@EJ24HRCEX0UU263 MINGW64 ~</div><div class="line">$ ssh -T git@github.com</div><div class="line">Hi jer0701! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure>
<ul>
<li>git add ./ 的时候显示filename too long    </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Users\Administrator\Desktop\MyProject\Blog&gt;git config --global core.longpaths true</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
