[{"title":"浅谈富文本编辑","date":"2017-03-24T08:00:33.000Z","path":"2017/03/24/ContentEditable/","text":"最近做的一个demo用到了富文本编辑， 然后我使用React框架来重写这个demo，需要处理富文本编辑功能，就有了此文章 说在前面的话富文本编辑，又称为WYSIWYG（What You See Is What You Get，所见即所得）， 该技术的本质，就是在页面中嵌入一个包含空HTML页面的iframe。 JavaScript实现富文本有两种方式，一种是使用iframe元素，另一种是使用contenteditable属性，本文讲的是后一种方法。 使用contenteditable属性可以把contenteditable属性应用给页面的任何元素，然后用户立即就可以编辑该元素。这种方法很受欢迎，因为它不需要iframe、空白页和JavaScript，只要为元素设置contenteditable属性即可，如下： 1&lt;div class=\"editable\" contenteditable==\"true\"&gt;&lt;/div&gt; contenteditable属性有三个可能的值：“true”表示打开、“false”表示关闭、“inherit”表示可以从父元素那里继承。 React中使用我在重写demo的时候是将可编辑的div做成react控件，以此达到目的。 代码如下： 1234567891011121314151617181920212223242526var ContentEditable = React.createClass(&#123; shouldComponentUpdate: function(nextProps)&#123; return nextProps.html !== ReactDOM.findDOMNode(this).innerHTML; &#125;, editChange: function()&#123; var html = ReactDOM.findDOMNode(this).innerHTML; if (this.props.onChange &amp;&amp; html !== this.lastHtml) &#123; this.props.onChange(&#123; target: &#123; value: html &#125; &#125;); &#125; this.lastHtml = html; &#125;, render: function()&#123; return &lt;div className=\"t_contant\" onInput=&#123;this.editChange&#125; onBlur=&#123;this.editChange&#125; contentEditable=\"true\" dangerouslySetInnerHTML=&#123;&#123;__html: this.props.html&#125;&#125;&gt;&lt;/div&gt;; &#125; &#125;); 由于div标签没有onChange事件，所以需要用onInput和onBlur来代替。 dangerouslySetInnerHTML是React特有的属性，用于提供插入纯 HTML 字符串的功能。 好的，基于以上控件，可编辑的div可用于React中。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yuanjer.com/tags/javascript/"},{"name":"contenteditable","slug":"contenteditable","permalink":"http://yuanjer.com/tags/contenteditable/"},{"name":"React","slug":"React","permalink":"http://yuanjer.com/tags/React/"}]},{"title":"React之扫盲","date":"2017-03-22T19:04:52.000Z","path":"2017/03/23/React3/","text":"学习React有一段时间了，React有一些细节还是要注意的。 本文便于扫盲~ 不多说废话，直接点出： React的核心是组件，那么第一个细节点是，组件类名第一个字母一定要大写，之前有过一篇文章提到过阮一峰老师的关于react入门教程，里面也提醒了这点，不过阮老师写的是：组件类的第一个字母必须大写，否则会报错。这里补充一下，不一定会报错，现代浏览器有很强的兼容性，这种可能不会报错，但是效果一定是显示不出来的。 ​ 在render的时候，行内样式不再是一个字符串，它是一个{}对象，值需要用{}括起来。 ​ React在访问像素为单位的属性的时候，它会自动补全px，所以我们在添加的时候，可以省略单位px，这也方便了我们在组件类内部对这些属性的计算等。 ​ 在组件中，所有的标签必须要有结束标签，例如img标签，一定要这样&lt;img /&gt;,不然就会报错，切记！ ​ render的时候只能有一个根节点，Only one! ​ 只有state改变了的时候，组件才会重新渲染，这个一般问题不大，这是React的核心算法。 ​ ref属性一般通过ReactDOM.findDOMNode方法来使用，查找真实的DOM节点。所有一般也在componentDidMount函数中使用ReactDOM.findDOMNode方法，因为这个时候DOM节点已经存在了。 个人能力暂时有限，目前只有这些。 ๑乛◡乛๑","tags":[{"name":"React","slug":"React","permalink":"http://yuanjer.com/tags/React/"}]},{"title":"React之通信","date":"2017-03-21T11:37:23.000Z","path":"2017/03/21/React2/","text":"今天这篇文章的目的是总结我今天做项目碰到的问题 方便以后查阅 需求先描述一下需求，我想在父组件（Heart）中添加子组件（Shadow），且子组件有很多个。子组件（Shadow）其他内容都相同，就是Color不同，所以只要在Shadow render的时候添加不同的颜色样式就可以了。 问题一在父组件中有个button，每点击一次产生一个阴影即添加一个子组件。 怎么控制呢？ 在父组件中添加一个state：shadows[]数组, 数组保存的是每一个子组件 123getInitialState: function() &#123; return &#123; shadows: [] &#125;;&#125; 当执行点击函数时，我们就push一个子组件进去，这样就可以点击一次添加一个子组件了。 12345handleClick: function(event) &#123; var temp = this.state.shadows; temp.push(&lt;Shadow /&gt;); this.setState(&#123;shadows: temp&#125;);&#125; 问题二解决问题一之后就会出现第二个问题，就是每添加一个子组件，都会产生一个DOM节点，不断的点击，就会保存很多个相同的DOM节点，因为每个子组件出现的效果只会显示很短的时间，效果没了之后，这些节点没有存在的必要了，所以有必要在效果结束之后删除这些节点。 问题来了，那么怎么删除呢？ 在这一步我卡了较久的时间，最开始想通过子组件自己删除自己，没有实现。。。 最后发现，可以根据问题一的解决来实现，通过父组件来删除子组件！ 在问题一种，我们添加了一个state：shadows[]数组，那么我每次从数组中pop出或者shift出一个元素，那不就可以了么。 1234567clearShadow: function() &#123; return function() &#123; var temp = this.state.shadows; temp.shift(); this.setState(&#123;shadows: temp&#125;); &#125;.bind(this);&#125; 接下来是什么时候删除呢，当然是效果完成之后，也就是子组件render之后。 所以我在子组件的componentDidMount函数中调用父组件的清除函数 12345componentDidMount: function() &#123; setTimeout(function() &#123; this.props.clearShadow(); &#125;.bind(this), 10000);&#125; 为什么在componentDidMount函数中调用呢，这就要谈及到组件的生命周期了。 这个可以查看官方文档 我在这里提一下生命周期提供的API: getDefaultProps 作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享 getInitialState 作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props componentWillMount 在完成首次渲染之前调用，此时仍可以修改组件的state render 必选的方法，创建虚拟DOM componentDidMount 真实的DOM被渲染出来后调用，在该方法中可访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM componentWillReceiveProps 组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state shouldComponentUpdate 组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化 componentWillUpdate 接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state componentDidUpdate 完成渲染新的props或者state后调用，此时可以访问到新的DOM元素 componentWillUnmount 组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器 博客标题是React之通信，今天说的就是父组件和子组件之间通信，有如下两个方法： 父组件调用子组件的方法：使用ref属性，子组件是一个DOM节点，可以通过this.refs.[refName] 就会返回这个真实的 DOM 节点。 子组件调用父组件方法：使用props属性，就是我今天使用的方法。 1temp.push(&lt;Shadow clearShadow=&#123;this.clearShadow()&#125;/&gt;); 然后就可以通过this.props.clearShadow()来调用了。 完美~","tags":[{"name":"React","slug":"React","permalink":"http://yuanjer.com/tags/React/"}]},{"title":"Canvas","date":"2017-03-20T13:34:19.000Z","path":"2017/03/20/Canvas/","text":"HTML5添加的最受欢迎的功能就是canvas元素 今天我就来学习学习它。 基本用法与浏览器环境中的其他组件类似，canvas由几组API构成，但非所有的浏览器都支持这些API。除了具备基本绘制能力的2D上下文，还有个WebGL的3D上下文。 要使用canvas元素，必须先设置其width和height属性，指定绘图的区域大小。出现在开始和结束标签中的内容是后备信息，如果浏览器不支持canvas元素，就会显示这些信息。如下 1&lt;canvas id=\"drawing\" width=\"200\" height=\"200\"&gt;Info&lt;/canvas&gt; 要在这块画布（canvas）上绘图，需要获得绘图上下文。通过getContext()方法调用, 传入“2d”，就可以获得2D上下文对象,如下 12345var draw = document.getElementById(\"drawing\");if (draw.getContext) &#123; //判断浏览器是否支持canvas元素 var context = draw.getContext(\"2d\"); ...&#125; 2D上下文使用2D绘图上下文提供的方法，可以绘制简单的2D图形，如矩形。2D上下文的坐标开始与canvas元素的左上角，坐标是(0,0)。所有坐标值基于这个点计算。 填充和描边2D上下文两种基本的操作就是填充和描边。操作的属性是：fillStyle和strokeStyle。 这两个属性的值默认都是“#000000” 123var context = draw.getContext(\"2d\");context.strokeStyle = \"red\";context.fillStyle = \"#0000ff\"; //蓝色 绘制矩形123//红色填充矩形context.fillStyle = \"red\";context.fillRect(10, 10, 50, 50); 123//红色描边矩形context.strokeStyle = \"red\";context.strokeRect(10, 10, 50, 50); 123456//在两个矩形重叠的地方清除一个小矩形context.fillStyle = \"red\";context.fillRect(10,10,50,50);context.fillStyle = \"rgba(0, 0, 255, 0.5)\";context.fillRect(30,30,50,50);context.clearRect(40, 40, 10, 10); 绘制路径要绘制路径，首先必须调用beginPath()方法，表示要开始绘制新路径了。 绘制路有很多方法 123456arc(x, y, radius, startAngle, endAngle, counterclockwise)arcTo(x1, y1, x2, y2, radius)bezierCurveTo(c1x, c1y, c2x, c2y, x, y)//绘制曲线，到x,y为止,途经c1,c2lineTo(x, y)moveTo(x, y)//移动光标，不画线rect(x, y, width, height) 看如下例子，绘制不带数字的时钟 123456789101112131415//开始路径context.beginPath();//绘制外圆context.arc(100, 100, 99, 0, 2*Math.PI, false);//绘制内圆context.moveTo(194, 100);context.arc(100, 100, 94, 0, 2*Math.PI, false);//绘制分针context.moveTo(100, 100);context.lineTo(100, 15);//绘制时针context.moveTo(100, 100);context.lineTo(35, 100);//描边刚刚画的路径context.stroke(); 绘制文本绘制文本有两个方法：fillText() 和strokeText()。这两个方法都可以接收四个参数：要绘制的字符串、x坐标、y坐标和可选的最大像素宽度。 1234context.font = \"blod 14px Microsoft\";context.textAlign = \"center\";context.textBaseLine = \"middle\";context.fillText(\"12\", 100, 20); 变换变换就是使用不同的变换矩阵处理图像，有如下变换矩阵： 12345rotate(angle) //围绕原点旋转scale(scaleX, scaleY) //x,轴缩放translate(x, y) //将原点坐标移到x,y，即(x,y)代表原点transform(m1_1, m1_2, m2_1, m2_2, dx, dy) //自定义修改矩阵setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy) //先把矩阵恢复默认再进行transform 绘制图像使用drawImage()方法就可以把图像绘制到画布上 1drawImage(image, x, y) //参数不固定，可以更多 阴影2D上下文会根据以下几个属性的值，自动为形状或路径绘制出阴影 1234shadowColor: 用CSS颜色格式表示阴影颜色，默认黑色shadowOffsetX: x轴方向阴影偏移量，默认为0shadowOffsetY: Y轴方向阴影偏移量，默认为0shadowBlur: 模糊的像素数，默认为0，即不模糊 这些属性可以通过context对象来修改，只要在绘制之前设置合适的值，就能自动产生阴影。例如下： 1234567context.shadowOffsetX = 5;context.shadowOffsetY = 5;context.Blur = 4;context.shadowColor = \"rgba(0, 0, 0, 0.5)\";context.fillStyle = \"red\";context.fillRect(10,10,50,50); 渐变渐变有CanvasGradient实例表示。 Context对象可以通过createLinearGradient()和createRadialGradient()两个方法创建渐变对象，这两个方法的参数如下： createLinearGradient(x1, y1, x2, y2); 创建一个从(x1, y1)点到(x2, y2)点的线性渐变对象。 createRadialGradient(x1, y1, r1, x2, y2, r2); 创建一个从以(x1, y1)点为圆心、r1为半径的圆到以(x2, y2)点为圆心、r2为半径的圆的径向渐变对象。 渐变对象创建完成之后必须使用它的addColorStop()方法来添加颜色，该方法的使用如下： addColorStop(position, color); 其中position表示添加颜色的位置，取值范围为[0, 1]，0表示起点，1表示终点；color表示添加的颜色，取值可以是任何CSS颜色值。 渐变对象创建并配置完成之后就可以将其赋予Context对象的strokeStyle属性或者fillStyle属性，然后绘制的图形就具有了所需的渐变效果。 123456var gradient = context.createLinearGradient(30, 30, 70, 70);gradient.addColorStop(0, \"white\");gradient.addColorStop(1, \"black\");context.fillStyle = gradient; //赋值给fillStyle属性context.fillRect(30, 30, 50, 50); 图像数据2D上下文的一个明显长处就是，可以通过getImageData()获取原始图像数据。这个方法接收四个参数：要获取器数据的画面区域的x、y坐标已经该区域的像素宽度和高度。 12//取得左上角坐标为(10,5)，大小为50 x 50像素的区域的图像数据var imageData = context.getImageData(10, 5, 50, 50); 上述代码返回的对象是ImageData的实例。每个ImageData对象有三个属性：width、height和data。其中data是一个数组，保存着图像每个像素的数据，分别是四个元素：红、绿、蓝和透明度值。例如下： 12345var data = imageData.data, red = data[0], green = data[1], blue = data[2], alpha = data[3]; 好了，到这里对canvas 2D上下文的基本用法就有了一定的了解，另外还有两个有意思的属性：globalAlpha和globalCompositionOperation，可去测试一下。","tags":[{"name":"canvas","slug":"canvas","permalink":"http://yuanjer.com/tags/canvas/"},{"name":"javascript","slug":"javascript","permalink":"http://yuanjer.com/tags/javascript/"}]},{"title":"React","date":"2017-03-20T11:00:13.000Z","path":"2017/03/20/React/","text":"最近在学习React框架，这是前端最热门框架之一了。 碰到过一些坑，在这里记录下来。 React入门React是Facebook开源的项目，是一套性能比较好的框架。为什么呢，因为采取虚拟DOM技术，通过对DOM的模拟，最大限度地减少与DOM的交互。 React代码逻辑比较简单，如果不会的推荐可以看一看阮一峰老师的入门教程 React Router接下来我讲讲碰到的坑了，没错，就是react路由的坑 react router上手也容易，大家可以去看阮一峰老师的教程 我在代码中是这样使用的 1234567891011import &#123;Router, Route, IndexRoute, hashHistory&#125; from 'react-router'...ReactDOM.render( (&lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path='/' component=&#123;App&#125; &gt; &lt;IndexRoute component=&#123;Gallery&#125;/&gt; &lt;Route path='/calculator' component=&#123;Calculator&#125; /&gt; &lt;/Route&gt; &lt;/Router&gt;), document.getElementById('app')); 因为是本地静态页面，所以使用hashHistory。 项目采用yoman脚手架搭建，react router安装是使用如下命令 1npm install -S react-router 然后npm start运行项目，发现报错了，如下 1Uncaught TypeError: Cannot read property 'location' of undefined location未定义 可是location是history的呀如下 1match:r.computeMatch(r.props.history.location.pathname) history等于hashHistory，react-router定义的，怎么会报错呢，郁闷呀。 开始以为是我的代码写错了，然后就去写了个demo，如下 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../build/react-router.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; var Link = ReactRouter.Link; var IndexLink = ReactRouter.IndexLink; var Router = ReactRouter.Router; var Route = ReactRouter.Route; var IndexRoute = ReactRouter.IndexRoute; var hashHistory = ReactRouter.hashHistory; var App = React.createClass(&#123; render : function()&#123; return ( &lt;div className=&quot;container&quot;&gt; Hello world! &lt;/div&gt; ) &#125; &#125;) ReactDOM.render( &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;/Route&gt; &lt;/Router&gt;, document.getElementById(&apos;example&apos;) ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 测试发现是OK的，页面显示正常。 但是修改一下： 12&lt;script src=\"../build/react-router.min.js\"&gt;&lt;/script&gt; 修改成&lt;script src=\"http://cdn.bootcss.com/react-router/4.0.0/react-router.min.js\"&gt;&lt;/script&gt; 然后在测试，发现报一样的错了。 原来我项目中安装react-router是安装最新的4.0的版本 12345678\"dependencies\": &#123; \"core-js\": \"^2.0.0\", \"normalize.css\": \"^4.0.0\", \"react\": \"^15.0.0\", \"react-addons-css-transition-group\": \"^15.4.2\", \"react-dom\": \"^15.0.0\", \"react-router\": \"^4.0.0\" &#125; 手动改为”^3.0.0”再npm install生成就OK了。 4.0版本改动比较大，大家可以看下这篇文章 好了，今天就记录到这吧.","tags":[{"name":"React","slug":"React","permalink":"http://yuanjer.com/tags/React/"},{"name":"React-Router","slug":"React-Router","permalink":"http://yuanjer.com/tags/React-Router/"}]},{"title":"My first blog","date":"2017-03-19T09:05:58.000Z","path":"2017/03/19/My-first-blog/","text":"这是我的第一篇博客，也代表着我走向前端的起点 本文记录了搭建此博客的过程（windows） 配置环境首先git bash、node.js、github该安装的安装，该申请账号的申请账号，没得问题。 github先创建一个github仓库，名字随意，如Blog 然后git clone到本地 1C:\\Users\\Administrator\\Desktop\\MyProject&gt;git clone git@github.com:jer0701/Blog.git hexonpm安装 hexo 1C:\\Users\\Administrator\\Desktop\\MyProject\\Blog&gt;npm install -g hexo 执行初始化 1C:\\Users\\Administrator\\Desktop\\MyProject\\Blog&gt;hexo init 好啦，到这里所有的安装工作都完成啦！ 生成静态页面1C:\\Users\\Administrator\\Desktop\\MyProject\\Blog&gt;hexo generate 本地启动1C:\\Users\\Administrator\\Desktop\\MyProject\\Blog&gt;hexo server 然后在浏览器输入http://localhost:4000，可以预览 我当时怎么也查看不了，最后发现把VPN代理关闭就可以看了 部署到github需要配置 _config.yml文件 ​ deploy: type: git repository: git@github.com:jer0701/Blog.git branch: gh-pages 然后部署 12C:\\Users\\Administrator\\Desktop\\MyProject\\Blog&gt;npm install hexo-deployer-git --saveC:\\Users\\Administrator\\Desktop\\MyProject\\Blog&gt;hexo deployranjo 然后通过访问http://jer0701.github.io/Blog/就可以了,至此，一个完整的博客搭建好了，你可以自己配置主题和域名๑乛◡乛๑ 问题及解决 hexo deploy 显示Permission denied (publickey). 12345678910111213141516171819debug1: Authentications that can continue: publickeydebug1: Next authentication method: publickeydebug1: Trying private key: /c/Users/Administrator/.ssh/id_rsadebug1: Trying private key: /c/Users/Administrator/.ssh/id_dsadebug1: Trying private key: /c/Users/Administrator/.ssh/id_ecdsadebug1: Trying private key: /c/Users/Administrator/.ssh/id_ed25519debug1: No more authentication methods to try.Permission denied (publickey).Administrator@EJ24HRCEX0UU263 MINGW64 ~$ ls ~/.sshgithub_rsa github_rsa.pub known_hosts###将github换成id开头Administrator@EJ24HRCEX0UU263 MINGW64 ~$ ssh -T git@github.comHi jer0701! You&apos;ve successfully authenticated, but GitHub does not provide shell access. git add ./ 的时候显示filename too long 1C:\\Users\\Administrator\\Desktop\\MyProject\\Blog&gt;git config --global core.longpaths true","tags":[{"name":"blog","slug":"blog","permalink":"http://yuanjer.com/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://yuanjer.com/tags/hexo/"}]}]